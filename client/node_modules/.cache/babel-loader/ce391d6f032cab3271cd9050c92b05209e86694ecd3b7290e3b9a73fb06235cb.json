{"ast":null,"code":"import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n  var _a;\n  if (!isObject(jws)) {\n    throw new JWSInvalid('Flattened JWS must be an object');\n  }\n  if (jws.protected === undefined && jws.header === undefined) {\n    throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n  }\n  if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n    throw new JWSInvalid('JWS Protected Header incorrect type');\n  }\n  if (jws.payload === undefined) {\n    throw new JWSInvalid('JWS Payload missing');\n  }\n  if (typeof jws.signature !== 'string') {\n    throw new JWSInvalid('JWS Signature missing or incorrect type');\n  }\n  if (jws.header !== undefined && !isObject(jws.header)) {\n    throw new JWSInvalid('JWS Unprotected Header incorrect type');\n  }\n  let parsedProt = {};\n  if (jws.protected) {\n    try {\n      const protectedHeader = base64url(jws.protected);\n      parsedProt = JSON.parse(decoder.decode(protectedHeader));\n    } catch (_b) {\n      throw new JWSInvalid('JWS Protected Header is invalid');\n    }\n  }\n  if (!isDisjoint(parsedProt, jws.header)) {\n    throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n  }\n  const joseHeader = {\n    ...parsedProt,\n    ...jws.header\n  };\n  const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n  let b64 = true;\n  if (extensions.has('b64')) {\n    b64 = parsedProt.b64;\n    if (typeof b64 !== 'boolean') {\n      throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n    }\n  }\n  const {\n    alg\n  } = joseHeader;\n  if (typeof alg !== 'string' || !alg) {\n    throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n  }\n  const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n  if (algorithms && !algorithms.has(alg)) {\n    throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n  }\n  if (b64) {\n    if (typeof jws.payload !== 'string') {\n      throw new JWSInvalid('JWS Payload must be a string');\n    }\n  } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n    throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n  }\n  let resolvedKey = false;\n  if (typeof key === 'function') {\n    key = await key(parsedProt, jws);\n    resolvedKey = true;\n  }\n  checkKeyType(alg, key, 'verify');\n  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n  const signature = base64url(jws.signature);\n  const verified = await verify(alg, key, signature, data);\n  if (!verified) {\n    throw new JWSSignatureVerificationFailed();\n  }\n  let payload;\n  if (b64) {\n    payload = base64url(jws.payload);\n  } else if (typeof jws.payload === 'string') {\n    payload = encoder.encode(jws.payload);\n  } else {\n    payload = jws.payload;\n  }\n  const result = {\n    payload\n  };\n  if (jws.protected !== undefined) {\n    result.protectedHeader = parsedProt;\n  }\n  if (jws.header !== undefined) {\n    result.unprotectedHeader = jws.header;\n  }\n  if (resolvedKey) {\n    return {\n      ...result,\n      key\n    };\n  }\n  return result;\n}","map":{"version":3,"names":["decode","base64url","verify","JOSEAlgNotAllowed","JWSInvalid","JWSSignatureVerificationFailed","concat","encoder","decoder","isDisjoint","isObject","checkKeyType","validateCrit","validateAlgorithms","flattenedVerify","jws","key","options","_a","protected","undefined","header","payload","signature","parsedProt","protectedHeader","JSON","parse","_b","joseHeader","extensions","Map","crit","b64","has","alg","algorithms","Uint8Array","resolvedKey","data","encode","verified","result","unprotectedHeader"],"sources":["C:/Users/rama_/Desktop/vicky uni/Henrry Prep Course/otrom2/Brainly-Front/client/node_modules/jose/dist/browser/jws/flattened/verify.js"],"sourcesContent":["import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch (_b) {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    const signature = base64url(jws.signature);\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        payload = base64url(jws.payload);\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}