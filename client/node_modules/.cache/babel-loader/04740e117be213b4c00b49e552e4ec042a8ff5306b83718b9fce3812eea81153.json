{"ast":null,"code":"import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n  constructor(enc, key, options) {\n    this.parent = enc;\n    this.key = key;\n    this.options = options;\n  }\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this.unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n    this.unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n  addRecipient() {\n    return this.parent.addRecipient(...arguments);\n  }\n  encrypt() {\n    return this.parent.encrypt(...arguments);\n  }\n  done() {\n    return this.parent;\n  }\n}\nexport class GeneralEncrypt {\n  constructor(plaintext) {\n    this._recipients = [];\n    this._plaintext = plaintext;\n  }\n  addRecipient(key, options) {\n    const recipient = new IndividualRecipient(this, key, {\n      crit: options === null || options === void 0 ? void 0 : options.crit\n    });\n    this._recipients.push(recipient);\n    return recipient;\n  }\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n  setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setSharedUnprotectedHeader can only be called once');\n    }\n    this._unprotectedHeader = sharedUnprotectedHeader;\n    return this;\n  }\n  setAdditionalAuthenticatedData(aad) {\n    this._aad = aad;\n    return this;\n  }\n  async encrypt(options) {\n    var _a, _b, _c;\n    if (!this._recipients.length) {\n      throw new JWEInvalid('at least one recipient must be added');\n    }\n    options = {\n      deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw\n    };\n    if (this._recipients.length === 1) {\n      const [recipient] = this._recipients;\n      const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, {\n        ...recipient.options,\n        ...options\n      });\n      let jwe = {\n        ciphertext: flattened.ciphertext,\n        iv: flattened.iv,\n        recipients: [{}],\n        tag: flattened.tag\n      };\n      if (flattened.aad) jwe.aad = flattened.aad;\n      if (flattened.protected) jwe.protected = flattened.protected;\n      if (flattened.unprotected) jwe.unprotected = flattened.unprotected;\n      if (flattened.encrypted_key) jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n      if (flattened.header) jwe.recipients[0].header = flattened.header;\n      return jwe;\n    }\n    let enc;\n    for (let i = 0; i < this._recipients.length; i++) {\n      const recipient = this._recipients[i];\n      if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n        throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n      }\n      const joseHeader = {\n        ...this._protectedHeader,\n        ...this._unprotectedHeader,\n        ...recipient.unprotectedHeader\n      };\n      const {\n        alg\n      } = joseHeader;\n      if (typeof alg !== 'string' || !alg) {\n        throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n      }\n      if (alg === 'dir' || alg === 'ECDH-ES') {\n        throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n      }\n      if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n        throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n      }\n      if (!enc) {\n        enc = joseHeader.enc;\n      } else if (enc !== joseHeader.enc) {\n        throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n      }\n      validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n      if (joseHeader.zip !== undefined) {\n        if (!this._protectedHeader || !this._protectedHeader.zip) {\n          throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n        }\n      }\n    }\n    const cek = generateCek(enc);\n    let jwe = {\n      ciphertext: '',\n      iv: '',\n      recipients: [],\n      tag: ''\n    };\n    for (let i = 0; i < this._recipients.length; i++) {\n      const recipient = this._recipients[i];\n      const target = {};\n      jwe.recipients.push(target);\n      const joseHeader = {\n        ...this._protectedHeader,\n        ...this._unprotectedHeader,\n        ...recipient.unprotectedHeader\n      };\n      const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n      if (i === 0) {\n        const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({\n          p2c\n        }).encrypt(recipient.key, {\n          ...recipient.options,\n          ...options,\n          [unprotected]: true\n        });\n        jwe.ciphertext = flattened.ciphertext;\n        jwe.iv = flattened.iv;\n        jwe.tag = flattened.tag;\n        if (flattened.aad) jwe.aad = flattened.aad;\n        if (flattened.protected) jwe.protected = flattened.protected;\n        if (flattened.unprotected) jwe.unprotected = flattened.unprotected;\n        target.encrypted_key = flattened.encrypted_key;\n        if (flattened.header) target.header = flattened.header;\n        continue;\n      }\n      const {\n        encryptedKey,\n        parameters\n      } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, {\n        p2c\n      });\n      target.encrypted_key = base64url(encryptedKey);\n      if (recipient.unprotectedHeader || parameters) target.header = {\n        ...recipient.unprotectedHeader,\n        ...parameters\n      };\n    }\n    return jwe;\n  }\n}","map":{"version":3,"names":["FlattenedEncrypt","unprotected","JWEInvalid","generateCek","isDisjoint","encryptKeyManagement","encode","base64url","validateCrit","IndividualRecipient","constructor","enc","key","options","parent","setUnprotectedHeader","unprotectedHeader","TypeError","addRecipient","arguments","encrypt","done","GeneralEncrypt","plaintext","_recipients","_plaintext","recipient","crit","push","setProtectedHeader","protectedHeader","_protectedHeader","setSharedUnprotectedHeader","sharedUnprotectedHeader","_unprotectedHeader","setAdditionalAuthenticatedData","aad","_aad","_a","_b","_c","length","deflateRaw","flattened","jwe","ciphertext","iv","recipients","tag","protected","encrypted_key","header","i","joseHeader","alg","Map","zip","undefined","cek","target","p2c","startsWith","setContentEncryptionKey","setKeyManagementParameters","encryptedKey","parameters"],"sources":["C:/Users/rama_/Desktop/vicky uni/Henrry Prep Course/otrom2/Brainly-Front/client/node_modules/jose/dist/browser/jwe/general/encrypt.js"],"sourcesContent":["import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt(options) {\n        var _a, _b, _c;\n        if (!this._recipients.length) {\n            throw new JWEInvalid('at least one recipient must be added');\n        }\n        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options, ...options });\n            let jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                if (!this._protectedHeader || !this._protectedHeader.zip) {\n                    throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n                }\n            }\n        }\n        const cek = generateCek(enc);\n        let jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    ...options,\n                    [unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||\n                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||\n                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });\n            target.encrypted_key = base64url(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}