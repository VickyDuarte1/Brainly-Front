{"ast":null,"code":"import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n  constructor(payload) {\n    if (!(payload instanceof Uint8Array)) {\n      throw new TypeError('payload must be an instance of Uint8Array');\n    }\n    this._payload = payload;\n  }\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n    this._unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n  async sign(key, options) {\n    if (!this._protectedHeader && !this._unprotectedHeader) {\n      throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n    }\n    if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n      ...this._protectedHeader,\n      ...this._unprotectedHeader\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n      b64 = this._protectedHeader.b64;\n      if (typeof b64 !== 'boolean') {\n        throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n      }\n    }\n    const {\n      alg\n    } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n      throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    checkKeyType(alg, key, 'sign');\n    let payload = this._payload;\n    if (b64) {\n      payload = encoder.encode(base64url(payload));\n    }\n    let protectedHeader;\n    if (this._protectedHeader) {\n      protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n    } else {\n      protectedHeader = encoder.encode('');\n    }\n    const data = concat(protectedHeader, encoder.encode('.'), payload);\n    const signature = await sign(alg, key, data);\n    const jws = {\n      signature: base64url(signature),\n      payload: ''\n    };\n    if (b64) {\n      jws.payload = decoder.decode(payload);\n    }\n    if (this._unprotectedHeader) {\n      jws.header = this._unprotectedHeader;\n    }\n    if (this._protectedHeader) {\n      jws.protected = decoder.decode(protectedHeader);\n    }\n    return jws;\n  }\n}","map":{"version":3,"names":["encode","base64url","sign","isDisjoint","JWSInvalid","encoder","decoder","concat","checkKeyType","validateCrit","FlattenedSign","constructor","payload","Uint8Array","TypeError","_payload","setProtectedHeader","protectedHeader","_protectedHeader","setUnprotectedHeader","unprotectedHeader","_unprotectedHeader","key","options","joseHeader","extensions","Map","crit","b64","has","alg","JSON","stringify","data","signature","jws","decode","header","protected"],"sources":["C:/Users/rama_/Desktop/vicky uni/Henrry Prep Course/otrom2/Brainly-Front/client/node_modules/jose/dist/browser/jws/flattened/sign.js"],"sourcesContent":["import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}