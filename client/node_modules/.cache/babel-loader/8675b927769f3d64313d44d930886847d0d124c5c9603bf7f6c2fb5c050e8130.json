{"ast":null,"code":"import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n  constructor(plaintext) {\n    if (!(plaintext instanceof Uint8Array)) {\n      throw new TypeError('plaintext must be an instance of Uint8Array');\n    }\n    this._plaintext = plaintext;\n  }\n  setKeyManagementParameters(parameters) {\n    if (this._keyManagementParameters) {\n      throw new TypeError('setKeyManagementParameters can only be called once');\n    }\n    this._keyManagementParameters = parameters;\n    return this;\n  }\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n  setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n    if (this._sharedUnprotectedHeader) {\n      throw new TypeError('setSharedUnprotectedHeader can only be called once');\n    }\n    this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n    return this;\n  }\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n    this._unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n  setAdditionalAuthenticatedData(aad) {\n    this._aad = aad;\n    return this;\n  }\n  setContentEncryptionKey(cek) {\n    if (this._cek) {\n      throw new TypeError('setContentEncryptionKey can only be called once');\n    }\n    this._cek = cek;\n    return this;\n  }\n  setInitializationVector(iv) {\n    if (this._iv) {\n      throw new TypeError('setInitializationVector can only be called once');\n    }\n    this._iv = iv;\n    return this;\n  }\n  async encrypt(key, options) {\n    if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n      throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n    }\n    if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n      throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n      ...this._protectedHeader,\n      ...this._unprotectedHeader,\n      ...this._sharedUnprotectedHeader\n    };\n    validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n    if (joseHeader.zip !== undefined) {\n      if (!this._protectedHeader || !this._protectedHeader.zip) {\n        throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n      }\n      if (joseHeader.zip !== 'DEF') {\n        throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n      }\n    }\n    const {\n      alg,\n      enc\n    } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n      throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    if (typeof enc !== 'string' || !enc) {\n      throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n    }\n    let encryptedKey;\n    if (alg === 'dir') {\n      if (this._cek) {\n        throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n      }\n    } else if (alg === 'ECDH-ES') {\n      if (this._cek) {\n        throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n      }\n    }\n    let cek;\n    {\n      let parameters;\n      ({\n        cek,\n        encryptedKey,\n        parameters\n      } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n      if (parameters) {\n        if (options && unprotected in options) {\n          if (!this._unprotectedHeader) {\n            this.setUnprotectedHeader(parameters);\n          } else {\n            this._unprotectedHeader = {\n              ...this._unprotectedHeader,\n              ...parameters\n            };\n          }\n        } else {\n          if (!this._protectedHeader) {\n            this.setProtectedHeader(parameters);\n          } else {\n            this._protectedHeader = {\n              ...this._protectedHeader,\n              ...parameters\n            };\n          }\n        }\n      }\n    }\n    this._iv || (this._iv = generateIv(enc));\n    let additionalData;\n    let protectedHeader;\n    let aadMember;\n    if (this._protectedHeader) {\n      protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n    } else {\n      protectedHeader = encoder.encode('');\n    }\n    if (this._aad) {\n      aadMember = base64url(this._aad);\n      additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n    } else {\n      additionalData = protectedHeader;\n    }\n    let ciphertext;\n    let tag;\n    if (joseHeader.zip === 'DEF') {\n      const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n      ({\n        ciphertext,\n        tag\n      } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n    } else {\n      ;\n      ({\n        ciphertext,\n        tag\n      } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n    }\n    const jwe = {\n      ciphertext: base64url(ciphertext),\n      iv: base64url(this._iv),\n      tag: base64url(tag)\n    };\n    if (encryptedKey) {\n      jwe.encrypted_key = base64url(encryptedKey);\n    }\n    if (aadMember) {\n      jwe.aad = aadMember;\n    }\n    if (this._protectedHeader) {\n      jwe.protected = decoder.decode(protectedHeader);\n    }\n    if (this._sharedUnprotectedHeader) {\n      jwe.unprotected = this._sharedUnprotectedHeader;\n    }\n    if (this._unprotectedHeader) {\n      jwe.header = this._unprotectedHeader;\n    }\n    return jwe;\n  }\n}","map":{"version":3,"names":["encode","base64url","encrypt","deflate","generateIv","encryptKeyManagement","JOSENotSupported","JWEInvalid","isDisjoint","encoder","decoder","concat","validateCrit","unprotected","Symbol","FlattenedEncrypt","constructor","plaintext","Uint8Array","TypeError","_plaintext","setKeyManagementParameters","parameters","_keyManagementParameters","setProtectedHeader","protectedHeader","_protectedHeader","setSharedUnprotectedHeader","sharedUnprotectedHeader","_sharedUnprotectedHeader","setUnprotectedHeader","unprotectedHeader","_unprotectedHeader","setAdditionalAuthenticatedData","aad","_aad","setContentEncryptionKey","cek","_cek","setInitializationVector","iv","_iv","key","options","joseHeader","Map","crit","zip","undefined","alg","enc","encryptedKey","additionalData","aadMember","JSON","stringify","ciphertext","tag","deflated","deflateRaw","jwe","encrypted_key","protected","decode","header"],"sources":["C:/Users/rama_/Desktop/vicky uni/Henrry Prep Course/otrom2/Brainly-Front/client/node_modules/jose/dist/browser/jwe/flattened/encrypt.js"],"sourcesContent":["import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n            iv: base64url(this._iv),\n            tag: base64url(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}